import os, socket as Socket, subprocess, requests
from .os import File, Parent
from .print import Print


class TORRC:
    """
    A `torrc` config file is generated by `Tor` based on these settings.  
    Defaults ideal for use of `tor.exe` to setup socks proxy for scraping.
    """
    SocksPort            = 9050
    ControlPort          = 9051
    CookieAuthentication = 1
    MaxCircuitDirtiness  = 10   # Default=600(10mins). Ensures Tor will *attempt* to use a new IP every 10 seconds.

    def Generate_Config_File(path):
        with open(path, "w", encoding="utf-8") as file:
            for name, value in vars(TORRC).items():
                if name.startswith("_") or callable(value): continue
                file.write(f"{name} {value}\n")

class Tor():
    """
    `Tor.Start()`
    `Tor.RotateIP()`
    `Tor.Stop()`
    """
    _TORRC   = File(Parent(__file__), 'torrc')
    _TOR_EXE = File(Parent(__file__), 'tor.exe')

    process:subprocess.Popen = None

    HOST = "127.0.0.1"
    socks_port = TORRC.SocksPort
    control_port = TORRC.ControlPort

    def __init__(self):
        if not os.path.exists(self._TOR_EXE):
            raise Exception('Tor: tor.exe required to start Tor')
        
        TORRC.Generate_Config_File(self._TORRC)

    def RotateIP():
        with open(control_auth_cookie.path(), "rb") as file:
            cookie = file.read().hex()
        
        with Socket.create_connection((Tor.HOST, Tor.control_port), timeout=5) as socket:
            def send(cmd:str):
                socket.sendall((cmd + "\r\n").encode("ascii"))
                return socket.recv(1024).decode()

            resp = send(f'AUTHENTICATE {cookie}')
            if not resp.startswith("250"): raise Exception(f"AUTH failed: {resp.strip()}")

            resp = send("SIGNAL NEWNYM")
            if not resp.startswith("250"): raise Exception(f"NEWNYM failed: {resp.strip()}")
            
    def Start():
        Tor()
        if os.name == 'nt':
            Tor.kill_windows_tor_processes()
            Tor.process = subprocess.Popen(
                [Tor._TOR_EXE, '-f', Tor._TORRC],
                creationflags=subprocess.CREATE_NO_WINDOW,                # flag is windows only, fyi
            )
            # Print.green(f'Tor started.')
        else:
            raise Exception('only windows currently supported')

    def Stop():
        if(Tor.process):
            Tor.process.terminate()
            os.remove(Tor._TORRC)
            # Print.green('Tor stopped.')

    def kill_windows_tor_processes():
        """ Ran at beginning to make sure no lingering tor processes alive from possible past runs """
        result = subprocess.run(
            ['tasklist', '/FI', 'IMAGENAME eq tor.exe'],        # list, filter, for 'tor.exe'
            capture_output=True,                                # capture stdout/stderr
            text=True                                           # result should be str, not byte obj
        )

        if "tor.exe" in result.stdout:
            Print.yellow('Tor(): tor.exe process(es) found. Spinning up subprocess.run[taskkill]...', False)
            result = subprocess.run(['taskkill', '/F', '/IM', 'tor.exe'], capture_output=True)
            if(result.returncode == 0):
                Print.green('Success!')
            else:
                Print.red(f'Failure!')
                Print.red(f'subprocess.run[taskkill] -> result.returncode: {result.returncode}')

class control_auth_cookie:
    WINDOWS_PATH = fr'{os.getenv("APPDATA")}\tor\control_auth_cookie'
    LINUX_PATH = '/var/lib/tor/control_auth_cookie'

    def path():
        if os.name == 'nt': return control_auth_cookie.WINDOWS_PATH
        else:               return control_auth_cookie.LINUX_PATH
